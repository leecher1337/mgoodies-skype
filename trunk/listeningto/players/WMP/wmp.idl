//*****************************************************************************
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
// FileName:            wmp.idl
//
// Abstract:            Interface definitions for all public Windows Media
//                      Player interfaces
//
//*****************************************************************************
cpp_quote( "//=========================================================================" )
cpp_quote( "//" )
cpp_quote( "// Microsoft Windows Media Technologies" )
cpp_quote( "// Copyright (C) Microsoft Corporation.  All Rights Reserved." )
cpp_quote( "//" )
cpp_quote( "//=========================================================================" )

#include <olectl.h>
#include "wmpids.h"

import "oaidl.idl";
import "ocidl.idl";

//////////////////////////////////////////////////////////////////////
//            PUBLIC ENUM TYPES 
//////////////////////////////////////////////////////////////////////

typedef
[
    helpstring( "State of opening process" ),
    public
]
enum WMPOpenState // wmpos
{
    [ helpstring( "Undefined" ) ]                                   wmposUndefined,
    [ helpstring( "New Playlist is about to be loaded" ) ]          wmposPlaylistChanging,
    [ helpstring( "Locating the playlist" ) ]                       wmposPlaylistLocating,
    [ helpstring( "Connecting to the server holding a playlist" ) ] wmposPlaylistConnecting,
    [ helpstring( "Loading a playlist" ) ]                          wmposPlaylistLoading,
    [ helpstring( "Opening a playlist" ) ]                          wmposPlaylistOpening,
    [ helpstring( "Playlist is open" ) ]                            wmposPlaylistOpenNoMedia,
    [ helpstring( "Playlist has changed" ) ]                        wmposPlaylistChanged,
    [ helpstring( "New media is about to be loaded" ) ]             wmposMediaChanging,
    [ helpstring( "Locating the media" ) ]                          wmposMediaLocating,
    [ helpstring( "Connecting to the server holding media" ) ]      wmposMediaConnecting,
    [ helpstring( "Loading media" ) ]                               wmposMediaLoading,
    [ helpstring( "Opening a media" ) ]                             wmposMediaOpening,
    [ helpstring( "Media is open" ) ]                               wmposMediaOpen,
    [ helpstring( "Starting codec acquisition" ) ]                  wmposBeginCodecAcquisition,
    [ helpstring( "End codec acquisition" ) ]                       wmposEndCodecAcquisition,
    [ helpstring( "Starting license acquisition" ) ]                wmposBeginLicenseAcquisition,
    [ helpstring( "End license acquisition" ) ]                     wmposEndLicenseAcquisition,
    [ helpstring( "Starting individualization" ) ]                  wmposBeginIndividualization,
    [ helpstring( "End individualization" ) ]                       wmposEndIndividualization,
    [ helpstring( "Waiting for media" ) ]                           wmposMediaWaiting,    
    [ helpstring( "Opening an URL whose type is not known" ) ]      wmposOpeningUnknownURL,    
} WMPOpenState;

typedef
[
    helpstring( "State of playback" ),
    public
]
enum WMPPlayState
{
    [ helpstring( "State is undefined" ) ]                      wmppsUndefined,
    [ helpstring( "Playback is stopped" ) ]                     wmppsStopped,
    [ helpstring( "Playback is paused" ) ]                      wmppsPaused,
    [ helpstring( "Stream is playing" ) ]                       wmppsPlaying,
    [ helpstring( "Stream is Scanning forward" ) ]              wmppsScanForward,
    [ helpstring( "Stream is Scanning in reverse" ) ]           wmppsScanReverse,
    [ helpstring( "Media is being buffered" ) ]                 wmppsBuffering,
    [ helpstring( "Waiting for streaming data" ) ]              wmppsWaiting,
    [ helpstring( "End of media reached" ) ]                    wmppsMediaEnded,
    [ helpstring( "Preparing new media" ) ]                     wmppsTransitioning,
    [ helpstring( "Ready to begin playing" ) ]                  wmppsReady,
    [ helpstring( "Trying to reconnect for streaming data" ) ]  wmppsReconnecting,
    [ helpstring( "Last playstate" ) ]                          wmppsLast
} WMPPlayState;


typedef
[
    helpstring("WMP Playlist Change Event Type"),
    public
]
enum WMPPlaylistChangeEventType
{
    [ helpstring( "Unknown" ) ]     wmplcUnknown = 0,
    [ helpstring( "Clear" ) ]       wmplcClear,
    [ helpstring( "InfoChange" ) ]  wmplcInfoChange,
    [ helpstring( "Move" ) ]        wmplcMove,
    [ helpstring( "Delete" ) ]      wmplcDelete,
    [ helpstring( "Insert" ) ]      wmplcInsert,
    [ helpstring( "Append" ) ]      wmplcAppend,
    [ helpstring( "Private" ) ]     wmplcPrivate,
    [ helpstring( "NameChange" ) ]  wmplcNameChange,
    [ helpstring( "Morph" ) ]       wmplcMorph,
    [ helpstring( "Sort" ) ]        wmplcSort,
    [ helpstring( "Last" ) ]        wmplcLast
} WMPPlaylistChangeEventType;





//////////////////////////////////////////////////////////////////////
//                  Forward interface declarations
//////////////////////////////////////////////////////////////////////

interface IWMPPlaylist;


//////////////////////////////////////////////////////////////////////
//                   PUBLIC INTERFACES
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//          Error Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(3614C646-3B3B-4de7-A81E-930E3F2127B3),
    dual,
    helpstring("IWMPErrorItem: Public interface."),
    pointer_default(unique)
]
interface IWMPErrorItem : IDispatch
{
    [ id(DISPID_WMPERRORITEM_ERRORCODE), propget, helpstring("Returns the error code") ]
        HRESULT errorCode( [out, retval] long * phr );
    [ id(DISPID_WMPERRORITEM_ERRORDESCRIPTION), propget, helpstring("Returns a description of the error") ]
        HRESULT errorDescription( [out, retval] BSTR * pbstrDescription );
    [ id(DISPID_WMPERRORITEM_ERRORCONTEXT), propget, helpstring("Returns context information for the error") ]
        HRESULT errorContext( [out, retval] VARIANT * pvarContext );
    [ id(DISPID_WMPERRORITEM_REMEDY), propget, helpstring("Returns remedy code for the error") ]
        HRESULT remedy( [out, retval] long * plRemedy );
    [ id(DISPID_WMPERRORITEM_CUSTOMURL), propget, helpstring("Returns a custom url for this error (if avail)") ]
        HRESULT customUrl( [out, retval] BSTR * pbstrCustomUrl );
}

[
    object,
    uuid(A12DCF7D-14AB-4c1b-A8CD-63909F06025B),
    dual,
    helpstring("IWMPError: Public interface."),
    pointer_default(unique)
]
interface IWMPError : IDispatch
{
    [ id(DISPID_WMPERROR_CLEARERRORQUEUE), helpstring("Clears the error queue") ]
        HRESULT clearErrorQueue();
    [ id(DISPID_WMPERROR_ERRORCOUNT), propget, helpstring("Returns the number of error items") ]
        HRESULT errorCount( [out, retval] long * plNumErrors );
    [ id(DISPID_WMPERROR_ITEM), propget, helpstring("Returns an error item object") ]
        HRESULT item( [in] long dwIndex, [out, retval] IWMPErrorItem ** ppErrorItem );
    [ id(DISPID_WMPERROR_WEBHELP), helpstring("Launches WebHelp") ]
        HRESULT webHelp();
}

//////////////////////////////////////////////////////////////////////
//          Media Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(94D55E95-3FAC-11d3-B155-00C04F79FAA6),
    dual,
    helpstring("IWMPMedia: Public interface."),
    pointer_default(unique)
]
interface IWMPMedia : IDispatch
{
    [ id( DISPID_WMPMEDIA_ISIDENTICAL ), propget, helpstring( "Determines if the supplied object is the same as the this one" ) ]
        HRESULT isIdentical([in] IWMPMedia *pIWMPMedia, [out, retval] VARIANT_BOOL *pvbool );
    [ 
        id( DISPID_WMPMEDIA_SOURCEURL ), propget, helpstring( "Returns the media URL" ) ]
        HRESULT sourceURL( [out, retval] BSTR *pbstrSourceURL );
    [ 
        id( DISPID_WMPMEDIA_NAME ), propget, helpstring( "Returns the name of the media" ) ]
        HRESULT name( [out, retval] BSTR *pbstrName);
    [ 
        id( DISPID_WMPMEDIA_NAME ), propput, helpstring( "Sets the name of the media" ) ]
        HRESULT name( [in] BSTR bstrName);
    [ 
        id( DISPID_WMPMEDIA_IMAGESOURCEWIDTH ), propget, helpstring( "Returns the original width of the source images" ) ]
        HRESULT imageSourceWidth( [out, retval] long *pWidth );
    [ 
        id( DISPID_WMPMEDIA_IMAGESOURCEHEIGHT ), propget, helpstring( "Returns the original height of the source images" ) ]
        HRESULT imageSourceHeight( [out, retval] long *pHeight );
    [ 
        id( DISPID_WMPMEDIA_MARKERCOUNT ), propget, helpstring( "Returns the number of markers in the file" ) ]
        HRESULT markerCount( [out, retval] long *pMarkerCount );
    [ 
        id( DISPID_WMPMEDIA_GETMARKERTIME ), helpstring( "Returns the time of a marker" ) ]
        HRESULT getMarkerTime( [in] long MarkerNum, [out, retval] double *pMarkerTime );
    [ 
        id( DISPID_WMPMEDIA_GETMARKERNAME ), helpstring( "Returns the name of a marker" ) ]
        HRESULT getMarkerName( [in] long MarkerNum, [out, retval] BSTR *pbstrMarkerName );
    [ 
        id( DISPID_WMPMEDIA_DURATION ), propget, helpstring( "Returns duration of current media" ) ]
        HRESULT duration( [out, retval] double * pDuration );
    [ 
        id( DISPID_WMPMEDIA_DURATIONSTRING ), propget, helpstring( "Returns duration of current media as a string" ) ]
        HRESULT durationString( [out, retval] BSTR * pbstrDuration );
    [ 
        id( DISPID_WMPMEDIA_ATTRIBUTECOUNT ), propget, helpstring( "Returns the count of the attributes associated with this media" ) ]
        HRESULT attributeCount( [out, retval] long *plCount );
    [ 
        id( DISPID_WMPMEDIA_GETATTRIBUTENAME ), helpstring( "Returns the name of the attribute whose index has been specified" ) ]
        HRESULT getAttributeName( [in] long lIndex, [out, retval] BSTR *pbstrItemName );
    [ 
        id( DISPID_WMPMEDIA_GETITEMINFO ), helpstring( "Returns the value of specified attribute for this media" ) ]
        HRESULT getItemInfo( [in] BSTR bstrItemName, [out, retval] BSTR *pbstrVal );
    [ 
        id( DISPID_WMPMEDIA_SETITEMINFO ), helpstring( "Sets the value of specified attribute for this media" ) ]
        HRESULT setItemInfo( [in] BSTR bstrItemName, [in] BSTR bstrVal );
    [ 
        id( DISPID_WMPMEDIA_GETITEMINFOBYATOM ), helpstring( "Gets an item info by atom" ) ]
        HRESULT getItemInfoByAtom( [in] long lAtom, [out, retval] BSTR* pbstrVal );
    [ 
        id( DISPID_WMPMEDIA_ISMEMBEROF ), helpstring( "Is the media a member of the given playlist" ) ]
        HRESULT isMemberOf( [in] IWMPPlaylist* pPlaylist, [out, retval] VARIANT_BOOL* pvarfIsMemberOf );
    [ 
        id( DISPID_WMPMEDIA_ISREADONLYITEM ), helpstring( "Is the attribute read only" ) ]
        HRESULT isReadOnlyItem( [in] BSTR bstrItemName, [out, retval] VARIANT_BOOL* pvarfIsReadOnly);
}    

//////////////////////////////////////////////////////////////////////
//          Control Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(74C09E02-F828-11d2-A74B-00A0C905F36E),
    dual,
    helpstring("IWMPControls: Public interface."),
    pointer_default(unique)
]
interface IWMPControls : IDispatch
{
    [ id( DISPID_WMPCONTROLS_ISAVAILABLE ), propget, helpstring( "Returns whether or not the specified media functionality is available" ) ]
        HRESULT isAvailable( [in] BSTR bstrItem, [out, retval] VARIANT_BOOL *pIsAvailable );
    [ id( DISPID_WMPCONTROLS_PLAY ),helpstring( "Begins playing media" ) ]
        HRESULT play();
    [ id( DISPID_WMPCONTROLS_STOP ),helpstring( "Stops play of media" ) ]
        HRESULT stop();
    [ id( DISPID_WMPCONTROLS_PAUSE ), helpstring( "Pauses play of media" ) ]
        HRESULT pause();
    [ id( DISPID_WMPCONTROLS_FASTFORWARD ), helpstring( "Fast play of media in forward direction" ) ]
        HRESULT fastForward();
    [ id( DISPID_WMPCONTROLS_FASTREVERSE ),helpstring( "Fast play of media in reverse direction" ) ]
        HRESULT fastReverse();
    [ id( DISPID_WMPCONTROLS_CURRENTPOSITION ), propget, helpstring( "Returns the current position in media" ) ]
        HRESULT currentPosition( [out, retval] double * pdCurrentPosition );
    [ id( DISPID_WMPCONTROLS_CURRENTPOSITION ), propput, helpstring( "sets the current position in media" ) ]
        HRESULT currentPosition( [in] double dCurrentPosition );
    [ id( DISPID_WMPCONTROLS_CURRENTPOSITIONSTRING ), propget, helpstring( "Returns the current position in media as a string" ) ]
        HRESULT currentPositionString( [out, retval] BSTR * pbstrCurrentPosition );
    [ id( DISPID_WMPCONTROLS_NEXT ), helpstring( "Sets the current item to the next item in the playlist" ) ]
        HRESULT next();
    [ id( DISPID_WMPCONTROLS_PREVIOUS ), helpstring( "Sets the current item to the previous item in the playlist" ) ]
        HRESULT previous();
    [ id( DISPID_WMPCONTROLS_CURRENTITEM ), propget, helpstring( "Returns/Sets the play item" ) ]
        HRESULT currentItem( [out, retval] IWMPMedia **ppIWMPMedia);
    [ id( DISPID_WMPCONTROLS_CURRENTITEM ), propput ]
        HRESULT currentItem( [in] IWMPMedia *pIWMPMedia );
    [ id( DISPID_WMPCONTROLS_CURRENTMARKER ), propget, helpstring( "Returns the current marker" ) ]
        HRESULT currentMarker( [out, retval] long *plMarker);
    [ id( DISPID_WMPCONTROLS_CURRENTMARKER ), propput, helpstring( "Sets the current marker" ) ]
        HRESULT currentMarker( [in] long lMarker);
    [ id( DISPID_WMPCONTROLS_PLAYITEM ), helpstring( "Sets the current item and plays it" )]
        HRESULT playItem( [in] IWMPMedia *pIWMPMedia );
}

//////////////////////////////////////////////////////////////////////
//          Settings Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(9104D1AB-80C9-4fed-ABF0-2E6417A6DF14),
    dual,
    helpstring("IWMPSettings: Public interface."),
    pointer_default(unique)
]
interface IWMPSettings : IDispatch
{
    [ id( DISPID_WMPSETTINGS_ISAVAILABLE ), propget, helpstring( "Returns whether or not the specified media functionality is available" ) ]
        HRESULT isAvailable( [in] BSTR bstrItem, [out, retval] VARIANT_BOOL *pIsAvailable );
    [ id( DISPID_WMPSETTINGS_AUTOSTART ), propget, helpstring( "Returns whether media should automatically begin playing" ) ]
        HRESULT autoStart( [out, retval] VARIANT_BOOL *pfAutoStart );
    [ id( DISPID_WMPSETTINGS_AUTOSTART ), propput, helpstring( "Sets whether media should automatically begin playing" ) ]
        HRESULT autoStart( [in] VARIANT_BOOL fAutoStart );

    [ id( DISPID_WMPSETTINGS_BASEURL ), propget, helpstring( "Returns the base URL used for relative path resolution" ) ]
        HRESULT baseURL( [out, retval] BSTR * pbstrBaseURL );
    [ id( DISPID_WMPSETTINGS_BASEURL ), propput, helpstring( "Sets the base URL used for relative path resolution" ) ]
        HRESULT baseURL( [in] BSTR bstrBaseURL );

    [ id( DISPID_WMPSETTINGS_DEFAULTFRAME ), propget, helpstring( "Returns the frame location that changes when a URL flip occurs" ) ]
        HRESULT defaultFrame( [out, retval] BSTR * pbstrDefaultFrame );
    [ id( DISPID_WMPSETTINGS_DEFAULTFRAME ), propput, helpstring( "Sets the frame location that changes when a URL flip occurs" ) ]
        HRESULT defaultFrame( [in] BSTR bstrDefaultFrame );

    [ id( DISPID_WMPSETTINGS_INVOKEURLS ), propget, helpstring( "Returns whether URL events should spawn a browser." ) ]
        HRESULT invokeURLs( [out, retval] VARIANT_BOOL *pfInvokeURLs );
    [ id( DISPID_WMPSETTINGS_INVOKEURLS ), propput, helpstring( "Sets whether URL events should spawn a browser." ) ]
        HRESULT invokeURLs( [in] VARIANT_BOOL fInvokeURLs );

    [ id( DISPID_WMPSETTINGS_MUTE ), propget, helpstring( "Returns whether audio should be muted." ) ]
        HRESULT mute( [out, retval] VARIANT_BOOL *pfMute );
    [ id( DISPID_WMPSETTINGS_MUTE ), propput, helpstring( "Sets audio mute." ) ]
        HRESULT mute( [in] VARIANT_BOOL fMute );

    [ id( DISPID_WMPSETTINGS_PLAYCOUNT ), propget, helpstring( "Returns how many times media should play" ) ]
        HRESULT playCount( [out, retval] long *plCount );
    [ id( DISPID_WMPSETTINGS_PLAYCOUNT ), propput, helpstring( "Sets whether media should automatically begin playing" ) ]
        HRESULT playCount( [in] long lCount );

    [ id( DISPID_WMPSETTINGS_RATE ), propget, helpstring( "Returns current playback rate" ) ]
        HRESULT rate( [out, retval] double * pdRate );
    [ id( DISPID_WMPSETTINGS_RATE ), propput, helpstring( "Sets current playback rate" ) ]
        HRESULT rate( [in] double dRate );

    [ id( DISPID_WMPSETTINGS_BALANCE ), propget, helpstring( "Returns current audio Balance" ) ]
        HRESULT balance( [out, retval] long * plBalance );
    [ id( DISPID_WMPSETTINGS_BALANCE ), propput, helpstring( "Sets audio Balance" ) ]
        HRESULT balance( [in] long lBalance );

    [ id( DISPID_WMPSETTINGS_VOLUME ), propget, helpstring( "Returns current audio volume" ) ]
        HRESULT volume( [out, retval] long * plVolume );
    [ id( DISPID_WMPSETTINGS_VOLUME ), propput, helpstring( "Sets audio volume" ) ]
        HRESULT volume( [in] long lVolume );

    [ id( DISPID_WMPSETTINGS_GETMODE ), helpstring( "Returns the mode of the playlist" ) ]
        HRESULT getMode(  [in] BSTR bstrMode, [out,retval] VARIANT_BOOL *pvarfMode );
    [ id( DISPID_WMPSETTINGS_SETMODE ), helpstring( "Sets the mode of the playlist" )  ]
        HRESULT setMode( [in] BSTR bstrMode, [in] VARIANT_BOOL varfMode );

    [ id( DISPID_WMPSETTINGS_ENABLEERRORDIALOGS ), propget, helpstring( "Returns whether error dialogs are shown by default when embedded" ) ]
        HRESULT enableErrorDialogs( [out, retval] VARIANT_BOOL *pfEnableErrorDialogs );
    [ id( DISPID_WMPSETTINGS_ENABLEERRORDIALOGS ), propput, helpstring( "Returns whether error dialogs are shown by default when embedded" ) ]
        HRESULT enableErrorDialogs( [in] VARIANT_BOOL fEnableErrorDialogs );

}

//////////////////////////////////////////////////////////////////////
//          ClosedCaption Interfaces
//////////////////////////////////////////////////////////////////////
[
    object,
    uuid(4F2DF574-C588-11d3-9ED0-00C04FB6E937),
    dual,
    helpstring("IWMPClosedCaption: Public interface."),
    pointer_default(unique)
]
interface IWMPClosedCaption : IDispatch
{
    [ id( DISPID_WMPCLOSEDCAPTION_SAMISTYLE ), propget, helpstring( "Returns the previously set SAMI style" ) ]
        HRESULT SAMIStyle( [out, retval] BSTR * pbstrSAMIStyle );
    [ id( DISPID_WMPCLOSEDCAPTION_SAMISTYLE ), propput, helpstring( "Sets the SAMI style" ) ]
        HRESULT SAMIStyle( [in] BSTR  bstrSAMIStyle );

    [ id( DISPID_WMPCLOSEDCAPTION_SAMILANG ), propget, helpstring( "Returns the previously set SAMI language" ) ]
        HRESULT SAMILang( [out, retval] BSTR * pbstrSAMILang );
    [ id( DISPID_WMPCLOSEDCAPTION_SAMILANG ), propput, helpstring( "Sets the SAMI language" ) ]
        HRESULT SAMILang( [in] BSTR  bstrSAMILang );

    [  id( DISPID_WMPCLOSEDCAPTION_SAMIFILENAME ), propget, helpstring( "Returns the previously set SAMI file name" ) ]
        HRESULT SAMIFileName( [out, retval] BSTR * pbstrSAMIFileName );
    [ id( DISPID_WMPCLOSEDCAPTION_SAMIFILENAME ), propput, helpstring( "Sets the SAMI file name" ) ]
        HRESULT SAMIFileName( [in] BSTR  bstrSAMIFileName );

    [ id( DISPID_WMPCLOSEDCAPTION_CAPTIONINGID ), propget, helpstring( "Returns the previously set Captioning ID" ) ]
        HRESULT captioningId( [out, retval] BSTR * pbstrCaptioningID );
    [ id( DISPID_WMPCLOSEDCAPTION_CAPTIONINGID ), propput, helpstring( "Sets the Captioning ID" ) ]
        HRESULT captioningId( [in] BSTR  bstrCaptioningID );

}

//////////////////////////////////////////////////////////////////////
//          Playlist Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(D5F0F4F1-130C-11d3-B14E-00C04F79FAA6),
    dual,
    helpstring("IWMPPlaylist: Public interface."),
    pointer_default(unique)
]
interface IWMPPlaylist : IDispatch
{
    // properties
    [ 
        id( DISPID_WMPPLAYLIST_COUNT ), propget, helpstring( "Returns the number of items in the playlist" ) ]
        HRESULT count( [out, retval] long *plCount );
    [ 
        id( DISPID_WMPPLAYLIST_NAME ), propget, helpstring( "Returns the name of the playlist" ) ]
        HRESULT name( [out, retval] BSTR *pbstrName);
    [ 
        id( DISPID_WMPPLAYLIST_NAME ), propput, helpstring( "Sets the name of the playlist" ) ]
        HRESULT name( [in] BSTR bstrName);
    [ 
        id( DISPID_WMPPLAYLIST_ATTRIBUTECOUNT ), propget, helpstring( "Returns the number of attributes associated with the playlist" ) ]
        HRESULT attributeCount( [out, retval] long *plCount);
    [ 
        id( DISPID_WMPPLAYLIST_ATTRIBUTENAME ), propget, helpstring( "Returns the name of an attribute specified by an index") ]
        HRESULT attributeName( [in] long lIndex, [out, retval] BSTR *pbstrAttributeName);
    [ 
        id( DISPID_WMPPLAYLIST_ITEM ), propget, helpstring( "Returns the item at the specified index" ) ]
        HRESULT item( long lIndex, [out, retval] IWMPMedia **ppIWMPMedia );
    [ 
        id( DISPID_WMPPLAYLIST_GETITEMINFO ), helpstring( "Returns the value of a playlist attribute" ) ]
        HRESULT getItemInfo( [in] BSTR bstrName, [out, retval] BSTR *pbstrVal );
    [ 
        id( DISPID_WMPPLAYLIST_SETITEMINFO ), helpstring( "Sets the value of a playlist attribute" ) ]
        HRESULT setItemInfo( [in] BSTR bstrName, [in] BSTR bstrValue );

    // methods
    [ id( DISPID_WMPPLAYLIST_ISIDENTICAL ), propget, helpstring( "Determines if the supplied object is the same as the this one" ) ]
        HRESULT isIdentical([in] IWMPPlaylist *pIWMPPlaylist, [out, retval] VARIANT_BOOL *pvbool );
    [ 
        id( DISPID_WMPPLAYLIST_CLEAR ), helpstring( "Removes all items from the playlist" ) ]
        HRESULT clear();
    [ 
        id( DISPID_WMPPLAYLIST_INSERTITEM ), helpstring( "Inserts an item into the playlist at the specified location" ) ]
        HRESULT insertItem( [in] long lIndex, [in] IWMPMedia *pIWMPMedia );
    [ 
        id( DISPID_WMPPLAYLIST_APPENDITEM ), helpstring( "Adds an item to the end of the playlist" ) ]
        HRESULT appendItem( [in] IWMPMedia *pIWMPMedia );
    [ 
        id( DISPID_WMPPLAYLIST_REMOVEITEM ), helpstring( "Removes the specified item from the playlist" ) ]
        HRESULT removeItem([in] IWMPMedia *pIWMPMedia );
    [ 
        id( DISPID_WMPPLAYLIST_MOVEITEM ), helpstring( "Changes the location of an item in the playlist" ) ]
        HRESULT moveItem(long lIndexOld, long lIndexNew );

}

   
//////////////////////////////////////////////////////////////////////
//          CDROM Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(cfab6e98-8730-11d3-b388-00c04f68574b),
    dual,
    helpstring("IWMPCdrom: Public interface."),
    pointer_default(unique)
]
interface IWMPCdrom : IDispatch
{
    // properties
    [  id( DISPID_WMPCDROM_DRIVESPECIFIER ), propget, helpstring( "Returns the CDROM drive specifier" ) ]
        HRESULT driveSpecifier ([out, retval] BSTR* pbstrDrive);

    [  id( DISPID_WMPCDROM_PLAYLIST ), propget, helpstring( "Returns the playlist of tracks currently in the CDROM drive" ) ]
        HRESULT playlist ([out, retval] IWMPPlaylist** ppPlaylist);

    // methods
    [  id( DISPID_WMPCDROM_EJECT ), helpstring( "Eject the CD in the CDROM drive" ) ]
        HRESULT eject ();
}

[
    object,
    uuid(EE4C8FE2-34B2-11d3-A3BF-006097C9B344),
    dual,
    helpstring("IWMPCdromCollection: Public interface."),
    pointer_default(unique)
]
interface IWMPCdromCollection : IDispatch
{
    // properties
    [  id( DISPID_WMPCDROMCOLLECTION_COUNT ), propget, helpstring( "Returns the number of items in the cdrom collection" ) ]
        HRESULT count( [out, retval] long *plCount );

    // methods
    [  id( DISPID_WMPCDROMCOLLECTION_ITEM ), helpstring( "Returns the CDROM object at the given index" ) ]
        HRESULT item( [in] long lIndex, [out, retval] IWMPCdrom **ppItem );

    [  id( DISPID_WMPCDROMCOLLECTION_GETBYDRIVESPECIFIER ), helpstring( "Returns the CDROM object associated with a particular drive specifier, e.g. F:" ) ]
        HRESULT getByDriveSpecifier( [in] BSTR bstrDriveSpecifier, [out, retval] IWMPCdrom** ppCdrom );
}
 
//////////////////////////////////////////////////////////////////////
//          MediaCollection Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(4a976298-8c0d-11d3-b389-00c04f68574b),
    dual,
    helpstring("IWMPStringCollection: Public interface."),
    pointer_default(unique)
]
interface IWMPStringCollection : IDispatch
{
    // properties
    [  id( DISPID_WMPSTRINGCOLLECTION_COUNT ), propget, helpstring( "Returns the number of items in the string collection" ) ]
        HRESULT count( [out, retval] long* plCount );
    
    // methods
    [  id( DISPID_WMPSTRINGCOLLECTION_ITEM ), helpstring( "Returns the string at the given index" ) ]
        HRESULT item( [in] long lIndex, [out, retval] BSTR* pbstrString );
}

[
    object,
    uuid(8363BC22-B4B4-4b19-989D-1CD765749DD1),
    dual,
    helpstring("IWMPMediaCollection: Public interface."),
    pointer_default(unique)
]
interface IWMPMediaCollection : IDispatch
{
    // methods
    [  id( DISPID_WMPMEDIACOLLECTION_ADD ), helpstring( "Creates a new media object" ) ]
        HRESULT add( [in] BSTR bstrURL, [out, retval] IWMPMedia **ppItem );
    [  id( DISPID_WMPMEDIACOLLECTION_GETALL ), helpstring( "Returns a collection of all the items" ) ]
        HRESULT getAll( [out, retval] IWMPPlaylist** ppMediaItems );
    [  id( DISPID_WMPMEDIACOLLECTION_GETBYNAME ), helpstring( "Returns a collection of items with the given name" ) ]
        HRESULT getByName( [in] BSTR bstrName, [out, retval] IWMPPlaylist **ppMediaItems );
    [  id( DISPID_WMPMEDIACOLLECTION_GETBYGENRE ), helpstring( "Returns a collection of items with the given genre" ) ]
        HRESULT getByGenre( [in] BSTR bstrGenre, [out, retval] IWMPPlaylist **ppMediaItems );
    [  id( DISPID_WMPMEDIACOLLECTION_GETBYAUTHOR ), helpstring( "Returns a collection of items by a given author" ) ]
        HRESULT getByAuthor( [in] BSTR bstrAuthor, [out, retval] IWMPPlaylist **ppMediaItems );
    [  id( DISPID_WMPMEDIACOLLECTION_GETBYALBUM ), helpstring( "Returns a collection of items from the given album" ) ]
        HRESULT getByAlbum( [in] BSTR bstrAlbum, [out, retval] IWMPPlaylist **ppMediaItems );
    [  id( DISPID_WMPMEDIACOLLECTION_GETBYATTRIBUTE ), helpstring( "Returns a collection of items with the given attribute" ) ]
        HRESULT getByAttribute( [in] BSTR bstrAttribute, [in] BSTR bstrValue, [out, retval] IWMPPlaylist **ppMediaItems );
    [  id( DISPID_WMPMEDIACOLLECTION_REMOVE ), helpstring( "Removes an item from the media collection" ) ]
        HRESULT remove( [in] IWMPMedia *pItem, [in] VARIANT_BOOL varfDeleteFile );
    [  id( DISPID_WMPMEDIACOLLECTION_GETATTRIBUTESTRINGCOLLECTION ), helpstring( "Returns the string collection associated with an attribute" ) ]
        HRESULT getAttributeStringCollection( [in] BSTR bstrAttribute, [in] BSTR bstrMediaType, [out, retval] IWMPStringCollection** ppStringCollection );
    [  id( DISPID_WMPMEDIACOLLECTION_GETMEDIAATOM ), helpstring( "Gets an atom associated with an item name which can be requested from an IWMPMedia out of this collection via getItemInfoByAtom" ) ]
        HRESULT getMediaAtom( [in] BSTR bstrItemName, [out, retval] long* plAtom);
    [  id( DISPID_WMPMEDIACOLLECTION_SETDELETED ), helpstring( "Sets the deleted flag on a media object" ) ]
        HRESULT setDeleted( [in] IWMPMedia* pItem, [in] VARIANT_BOOL varfIsDeleted );
    [  id( DISPID_WMPMEDIACOLLECTION_ISDELETED ), helpstring( "Gets the deleted flag on a media object" ) ]
        HRESULT isDeleted( [in] IWMPMedia* pItem, [out, retval] VARIANT_BOOL* pvarfIsDeleted );
}

//////////////////////////////////////////////////////////////////////
//          PlaylistCollection Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(679409c0-99f7-11d3-9fb7-00105aa620bb),
    dual,
    helpstring("IWMPPlaylistArray: Public interface."),
    pointer_default(unique)
]
interface IWMPPlaylistArray : IDispatch
{
    // properties
    [  id( DISPID_WMPPLAYLISTARRAY_COUNT ), propget, helpstring( "Returns the number of items in the playlist array" ) ]
        HRESULT count( [out, retval] long *plCount );

    // methods
    [  id( DISPID_WMPPLAYLISTARRAY_ITEM ), helpstring( "Returns the playlist object at the given index" ) ]
        HRESULT item( [in] long lIndex, [out, retval] IWMPPlaylist **ppItem );
}

[
    object,
    uuid(10A13217-23A7-439b-B1C0-D847C79B7774),
    dual,
    helpstring("IWMPPlaylistCollection: Public interface."),
    pointer_default(unique)
]
interface IWMPPlaylistCollection : IDispatch
{
    // methods
    [  id( DISPID_WMPPLAYLISTCOLLECTION_NEWPLAYLIST ), helpstring( "Creates a new playlist object" ) ]
        HRESULT newPlaylist( [in] BSTR bstrName, [out, retval] IWMPPlaylist **ppItem );
    [  id( DISPID_WMPPLAYLISTCOLLECTION_GETALL ), helpstring( "Returns a playlist array with all the playlists" ) ]
        HRESULT getAll( [out, retval] IWMPPlaylistArray **ppPlaylistArray );
    [  id( DISPID_WMPPLAYLISTCOLLECTION_GETBYNAME ), helpstring( "Returns a playlist array with playlists matching the given name" ) ]
        HRESULT getByName( [in] BSTR bstrName, [out, retval] IWMPPlaylistArray **ppPlaylistArray );
    [  id( DISPID_WMPPLAYLISTCOLLECTION_REMOVE ), helpstring( "Removes an item from the playlist collection" ) ]
        HRESULT remove( [in] IWMPPlaylist *pItem );
    [  id( DISPID_WMPPLAYLISTCOLLECTION_SETDELETED ), helpstring( "Sets the deleted flag on a playlist object" ) ]
        HRESULT setDeleted( [in] IWMPPlaylist* pItem, [in] VARIANT_BOOL varfIsDeleted );
    [  id( DISPID_WMPPLAYLISTCOLLECTION_ISDELETED ), helpstring( "Gets the deleted flag on a playlist object" ) ]
        HRESULT isDeleted( [in] IWMPPlaylist* pItem, [out, retval] VARIANT_BOOL* pvarfIsDeleted );
    [  id( DISPID_WMPPLAYLISTCOLLECTION_IMPORTPLAYLIST ), helpstring( "Imports a playlist object into the library" ) ]
        HRESULT importPlaylist( [in] IWMPPlaylist* pItem, [out, retval] IWMPPlaylist** ppImportedItem );
}

//////////////////////////////////////////////////////////////////////
//          Network Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(EC21B779-EDEF-462d-BBA4-AD9DDE2B29A7),
    dual,
    helpstring("IWMPNetwork: Public interface."),
    pointer_default(unique)
]
interface IWMPNetwork : IDispatch
{
    // properties
    [ id( DISPID_WMPNETWORK_BANDWIDTH ), propget, helpstring( "Returns the current bandwidth of the clip." ) ]
        HRESULT bandWidth( [out, retval] long *plBandwidth );
    [ id( DISPID_WMPNETWORK_RECOVEREDPACKETS ), propget, helpstring( "Returns the number of recovered packets" ) ]
        HRESULT recoveredPackets( [out, retval] long *plRecoveredPackets );
    [ id( DISPID_WMPNETWORK_SOURCEPROTOCOL ), propget, helpstring( "Returns the source protocol used to receive data." ) ]
        HRESULT sourceProtocol( [out, retval] BSTR *pbstrSourceProtocol );
    [ id( DISPID_WMPNETWORK_RECEIVEDPACKETS ), propget, helpstring( "Returns the number of packets received." ) ]
        HRESULT receivedPackets( [out, retval] long *plReceivedPackets );
    [ id( DISPID_WMPNETWORK_LOSTPACKETS ), propget, helpstring( "Returns the number of packets lost." ) ]
        HRESULT lostPackets( [out, retval] long *plLostPackets );
    [ id( DISPID_WMPNETWORK_RECEPTIONQUALITY ), propget, helpstring( "Returns the percentage of packets received in the last 15 seconds." ) ]
        HRESULT receptionQuality( [out, retval] long *plReceptionQuality );
    [ id( DISPID_WMPNETWORK_BUFFERINGCOUNT ), propget, helpstring( "Returns the number of times buffering occurred during clip playback." ) ]
        HRESULT bufferingCount( [out, retval] long *plBufferingCount );
    [ id( DISPID_WMPNETWORK_BUFFERINGPROGRESS ), propget, helpstring( "Returns the percentage of buffering completed." ) ]
        HRESULT bufferingProgress( [out, retval] long *plBufferingProgress );
    [ id( DISPID_WMPNETWORK_BUFFERINGTIME ), propget, helpstring( "Returns the number of seconds allocated for buffering for this media type." ) ]
        HRESULT bufferingTime( [out, retval] long *plBufferingTime );
    [ id( DISPID_WMPNETWORK_BUFFERINGTIME ), propput, helpstring( "Sets the amount of time in milliseconds that the player allocates for buffering incoming data." ) ]
        HRESULT bufferingTime( [in] long lBufferingTime );
    [ id( DISPID_WMPNETWORK_FRAMERATE ), propget, helpstring( "Current video frame rate in frames/second" ) ]
        HRESULT frameRate( [out, retval] long *plFrameRate );
    [ id( DISPID_WMPNETWORK_MAXBITRATE ), propget, helpstring( "Maximum possible video bit rate" ) ]
        HRESULT maxBitRate( [out, retval] long *plBitRate );
    [ id( DISPID_WMPNETWORK_BITRATE ), propget, helpstring( "Current video bit rate" ) ]
        HRESULT bitRate( [out, retval] long *plBitRate );
    [ id( DISPID_WMPNETWORK_GETPROXYSETTINGS ), helpstring( "Returns the proxy settings for the specified protocol" ) ]
        HRESULT getProxySettings( [in] BSTR bstrProtocol, [out, retval] long *plProxySetting );
    [  id( DISPID_WMPNETWORK_SETPROXYSETTINGS ), helpstring( "Sets the proxy settings for the specified protocol" ) ]
        HRESULT setProxySettings( [in] BSTR bstrProtocol, [in] long lProxySetting );
    [ id( DISPID_WMPNETWORK_GETPROXYNAME ), helpstring( "Returns the proxy name for the specified protocol" ) ]
        HRESULT getProxyName( [in] BSTR bstrProtocol, [out, retval] BSTR *pbstrProxyName );
    [  id( DISPID_WMPNETWORK_SETPROXYNAME ), helpstring( "Sets the proxy name for the specified protocol" ) ]
        HRESULT setProxyName( [in] BSTR bstrProtocol, [in] BSTR bstrProxyName );
    [ id( DISPID_WMPNETWORK_GETPROXYPORT ), helpstring( "Returns the proxy port for the specified protocol" ) ]
        HRESULT getProxyPort( [in] BSTR bstrProtocol, [out, retval] long * lProxyPort );
    [  id( DISPID_WMPNETWORK_SETPROXYPORT ), helpstring( "Sets the proxy port for the specified protocol" ) ]
        HRESULT setProxyPort( [in] BSTR bstrProtocol, [in] long lProxyPort );
    [ id( DISPID_WMPNETWORK_GETPROXYEXCEPTIONLIST ), helpstring( "Returns the proxy exception list for the specified protocol" ) ]
        HRESULT getProxyExceptionList( [in] BSTR bstrProtocol, [out, retval] BSTR *pbstrExceptionList );
    [  id( DISPID_WMPNETWORK_SETPROXYEXCEPTIONLIST ), helpstring( "Sets the proxy exception list for the specified protocol" ) ]
        HRESULT setProxyExceptionList( [in] BSTR bstrProtocol, [in] BSTR pbstrExceptionList );
    [ id( DISPID_WMPNETWORK_GETPROXYBYPASSFORLOCAL ), helpstring( "Returns whether or not to bypass the proxy for local addresses" ) ]
        HRESULT getProxyBypassForLocal( [in] BSTR bstrProtocol, [out, retval] VARIANT_BOOL *pfBypassForLocal );
    [  id( DISPID_WMPNETWORK_SETPROXYBYPASSFORLOCAL ), helpstring( "Sets whether or not to by pass the proxy for local addresses" ) ]
        HRESULT setProxyBypassForLocal( [in] BSTR bstrProtocol, [in] VARIANT_BOOL fBypassForLocal );
    [ id( DISPID_WMPNETWORK_MAXBANDWIDTH ), propget, helpstring( "Returns or sets maximum allowed bandwidth" ) ]
        HRESULT maxBandwidth( [out, retval] long * lMaxBandwidth );
    [ id( DISPID_WMPNETWORK_MAXBANDWIDTH ), propput ]
        HRESULT maxBandwidth( [in] long lMaxBandwidth );
    [ id( DISPID_WMPNETWORK_DOWNLOADPROGRESS ), propget, helpstring( "Returns the percentage of download completed." ) ]
        HRESULT downloadProgress( [out, retval] long *plDownloadProgress );
    [ id( DISPID_WMPNETWORK_ENCODEDFRAMERATE ), propget, helpstring( "Returns the video frame rate, in frames/second, that the file was encoded in" ) ]
        HRESULT encodedFrameRate( [out, retval] long *plFrameRate );
    [ id( DISPID_WMPNETWORK_FRAMESSKIPPED ), propget, helpstring( "Returns the number of skipped frames" ) ]
        HRESULT framesSkipped( [out, retval] long *plFrames );
}
 
//////////////////////////////////////////////////////////////////////
//          Core Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(D84CCA99-CCE2-11d2-9ECC-0000F8085981),
    dual,
    helpstring("IWMPCore: Public interface."),
    pointer_default(unique)
]
interface IWMPCore : IDispatch
{
    // methods

    [ id(DISPID_WMPCORE_CLOSE), helpstring("Closes the media") ]
        HRESULT close();

    // properties

    [ id( DISPID_WMPCORE_URL ), propget, helpstring( "Returns or sets the URL" ) ]
        HRESULT URL( [out, retval] BSTR *pbstrURL );
    [  id( DISPID_WMPCORE_URL ), propput ]
        HRESULT URL( [in] BSTR bstrURL );
    [ id( DISPID_WMPCORE_OPENSTATE ), propget, helpstring( "Returns the open state of the player" ) ]
        HRESULT openState( [out, retval] WMPOpenState *pwmpos );
    [ id( DISPID_WMPCORE_PLAYSTATE ), propget, helpstring( "Returns the play state of the player" ) ]
        HRESULT playState( [out, retval] WMPPlayState *pwmpps );
    [ id(DISPID_WMPCORE_CONTROLS), propget, helpstring("Returns the control handler")]
        HRESULT controls([out, retval] IWMPControls **ppControl);
    [ id(DISPID_WMPCORE_SETTINGS), propget, helpstring("Returns the settings handler")]
        HRESULT settings([out, retval] IWMPSettings **ppSettings);
    [  id(DISPID_WMPCORE_CURRENTMEDIA), propget, helpstring("Returns or sets the current media object")]
        HRESULT currentMedia([out, retval] IWMPMedia **ppMedia);
    [  id(DISPID_WMPCORE_CURRENTMEDIA), propput]
        HRESULT currentMedia([in] IWMPMedia *pMedia);
    [  id(DISPID_WMPCORE_MEDIACOLLECTION), propget, helpstring("Returns the media collection handler")]
        HRESULT mediaCollection([out, retval] IWMPMediaCollection **ppMediaCollection);
    [  id(DISPID_WMPCORE_PLAYLISTCOLLECTION), propget, helpstring("Returns the playlist collection handler")]
        HRESULT playlistCollection([out, retval] IWMPPlaylistCollection **ppPlaylistCollection);
    [ id( DISPID_WMPCORE_VERSIONINFO ), propget, helpstring( "Returns the version information for the player" ) ]
        HRESULT versionInfo( [out, retval] BSTR * pbstrVersionInfo );

    [id ( DISPID_WMPCORE_LAUNCHURL)]
        HRESULT launchURL([in] BSTR bstrURL);

    [propget, id(DISPID_WMPCORE_NETWORK), helpstring("Returns the network information handler")]
        HRESULT network([out, retval] IWMPNetwork **ppQNI);
    [  id( DISPID_WMPCORE_CURRENTPLAYLIST), propget, helpstring( "Returns/sets the current playlist" ) ]
        HRESULT currentPlaylist( [out, retval] IWMPPlaylist **ppPL );
    [  id( DISPID_WMPCORE_CURRENTPLAYLIST), propput, helpstring( "Returns the playlist handler" ) ]
        HRESULT currentPlaylist( [in] IWMPPlaylist *pPL );
    [  id( DISPID_WMPCORE_CDROMCOLLECTION ), propget, helpstring("Get the CDROM drive collection") ]
        HRESULT cdromCollection ([out, retval] IWMPCdromCollection** ppCdromCollection);
    [ id(DISPID_WMPCORE_CLOSEDCAPTION), propget, helpstring("Returns the closed caption handler")]
        HRESULT closedCaption([out, retval] IWMPClosedCaption **ppClosedCaption);
    [ id(DISPID_WMPCORE_ISONLINE), propget, helpstring( "Returns whether the machine is online." ) ]
        HRESULT isOnline( [out, retval] VARIANT_BOOL *pfOnline );
    [ id(DISPID_WMPCORE_ERROR), propget, helpstring("Returns the error object")]
        HRESULT error([out, retval] IWMPError **ppError);
    [ id(DISPID_WMPCORE_STATUS), propget, helpstring("Returns status string")]
        HRESULT status([out, retval] BSTR *pbstrStatus);
}

//////////////////////////////////////////////////////////////////////
//          Player Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(6BF52A4F-394A-11d3-B153-00C04F79FAA6),
    dual,
    helpstring("IWMPPlayer: Public interface."),
    pointer_default(unique)
]
interface IWMPPlayer : IWMPCore
{
    [ id(DISPID_WMPOCX_ENABLED), propget, helpstring("Returns a boolen value specifying whether or not the control is enabled")]
        HRESULT enabled([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX_ENABLED), propput, helpstring("Sets a boolean value specifying whether or not the control is enabled")]
        HRESULT enabled([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX_FULLSCREEN), propget, helpstring("Returns a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen([out, retval] VARIANT_BOOL *pbFullScreen);
    [ id(DISPID_WMPOCX_FULLSCREEN), propput, helpstring("Sets a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen(VARIANT_BOOL bFullScreen);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propget, helpstring("Returns a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu([out, retval] VARIANT_BOOL *pbEnableContextMenu);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propput, helpstring("Sets a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu(VARIANT_BOOL bEnableContextMenu);
    [ id(DISPID_WMPOCX_UIMODE), propput, helpstring("Specifies the ui mode to select")]
        HRESULT uiMode([in] BSTR bstrMode);
    [ id(DISPID_WMPOCX_UIMODE), propget, helpstring("Returns the currently selected ui mode")]
        HRESULT uiMode([out, retval] BSTR *pbstrMode);
}




//////////////////////////////////////////////////////////////////////
//          Player2 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(0E6B01D1-D407-4c85-BF5F-1C01F6150280),
    dual,
    helpstring("IWMPPlayer2: Public interface."),
    pointer_default(unique)
]
interface IWMPPlayer2 : IWMPCore
{
    [ id(DISPID_WMPOCX_ENABLED), propget, helpstring("Returns a boolen value specifying whether or not the control is enabled")]
        HRESULT enabled([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX_ENABLED), propput, helpstring("Sets a boolean value specifying whether or not the control is enabled")]
        HRESULT enabled([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX_FULLSCREEN), propget, helpstring("Returns a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen([out, retval] VARIANT_BOOL *pbFullScreen);
    [ id(DISPID_WMPOCX_FULLSCREEN), propput, helpstring("Sets a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen(VARIANT_BOOL bFullScreen);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propget, helpstring("Returns a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu([out, retval] VARIANT_BOOL *pbEnableContextMenu);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propput, helpstring("Sets a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu(VARIANT_BOOL bEnableContextMenu);
    [ id(DISPID_WMPOCX_UIMODE), propput, helpstring("Specifies the ui mode to select")]
        HRESULT uiMode([in] BSTR bstrMode);
    [ id(DISPID_WMPOCX_UIMODE), propget, helpstring("Returns the currently selected ui mode")]
        HRESULT uiMode([out, retval] BSTR *pbstrMode);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propget, helpstring("Returns a boolen value specifying whether or not video is stretched")]
        HRESULT stretchToFit([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propput, helpstring("Sets a boolean value specifying whether or not video is stretched")]
        HRESULT stretchToFit([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propget, helpstring("Returns a boolen value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propput, helpstring("Sets a boolean value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([in] VARIANT_BOOL bEnabled);
}




//////////////////////////////////////////////////////////////////////
//          Media2 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(AB7C88BB-143E-4ea4-ACC3-E4350B2106C3),
    dual,
    helpstring("IWMPMedia2: Public interface."),
    pointer_default(unique)
]
interface IWMPMedia2 : IWMPMedia
{
    [ id( DISPID_WMPMEDIA2_ERROR ), propget, helpstring( "Returns an error item pointer for a media specific error" ) ]
        HRESULT error( [out, retval] IWMPErrorItem **ppIWMPErrorItem );
}


//////////////////////////////////////////////////////////////////////
//          Control2 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(6F030D25-0890-480f-9775-1F7E40AB5B8E),
    dual,
    helpstring("IWMPControls2: Public interface."),
    pointer_default(unique)
]
interface IWMPControls2 : IWMPControls
{
    [ id( DISPID_WMPCONTROLS2_STEP ), helpstring( "Advances the video one frame" )]
        HRESULT step([in] long lStep );
}

 
//////////////////////////////////////////////////////////////////////
//          DVD Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(8DA61686-4668-4a5c-AE5D-803193293DBE),
    dual,
    helpstring("IWMPDVD: Public interface."),
    pointer_default(unique)
]
interface IWMPDVD : IDispatch
{
    [ id( DISPID_WMPDVD_ISAVAILABLE ), propget, helpstring( "Returns whether or not the specified DVD functionality is available" ) ]
        HRESULT isAvailable( [in] BSTR bstrItem, [out, retval] VARIANT_BOOL *pIsAvailable );
    [ id( DISPID_WMPDVD_DOMAIN ), propget, helpstring( "Returns the current DVD domain" ) ]
        HRESULT domain( [out, retval] BSTR * strDomain );
    [ id( DISPID_WMPDVD_TOPMENU ), helpstring( "Displays the top menu of the DVD" ) ]
        HRESULT topMenu();
    [ id( DISPID_WMPDVD_TITLEMENU ), helpstring( "Displays the title menu of the current DVD title" ) ]
        HRESULT titleMenu();
    [ id( DISPID_WMPDVD_BACK ), helpstring( "Navigates back one menu" ) ]
        HRESULT back();
    [ id( DISPID_WMPDVD_RESUME ), helpstring( "Removes the menu from the screen and returns to playing the DVD" ) ]
        HRESULT resume();
}

//////////////////////////////////////////////////////////////////////
//          Core2 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(BC17E5B7-7561-4c18-BB90-17D485775659),
    dual,
    helpstring("IWMPCore2: Public interface."),
    pointer_default(unique)
]
interface IWMPCore2 : IWMPCore
{
    [ id(DISPID_WMPCORE2_DVD), propget, helpstring("Returns the DVD handler")]
        HRESULT dvd([out, retval] IWMPDVD ** ppDVD);
}


//////////////////////////////////////////////////////////////////////
//          Player3 Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(54062B68-052A-4c25-A39F-8B63346511D4),
    dual,
    helpstring("IWMPPlayer3: Public interface."),
    pointer_default(unique)
]
interface IWMPPlayer3 : IWMPCore2
{
    [ id(DISPID_WMPOCX_ENABLED), propget, helpstring("Returns a boolen value specifying whether or not the control is enabled")]
        HRESULT enabled([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX_ENABLED), propput, helpstring("Sets a boolean value specifying whether or not the control is enabled")]
        HRESULT enabled([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX_FULLSCREEN), propget, helpstring("Returns a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen([out, retval] VARIANT_BOOL *pbFullScreen);
    [ id(DISPID_WMPOCX_FULLSCREEN), propput, helpstring("Sets a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen(VARIANT_BOOL bFullScreen);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propget, helpstring("Returns a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu([out, retval] VARIANT_BOOL *pbEnableContextMenu);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propput, helpstring("Sets a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu(VARIANT_BOOL bEnableContextMenu);
    [ id(DISPID_WMPOCX_UIMODE), propput, helpstring("Specifies the ui mode to select")]
        HRESULT uiMode([in] BSTR bstrMode);
    [ id(DISPID_WMPOCX_UIMODE), propget, helpstring("Returns the currently selected ui mode")]
        HRESULT uiMode([out, retval] BSTR *pbstrMode);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propget, helpstring("Returns a boolen value specifying whether or not video is stretched")]
        HRESULT stretchToFit([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propput, helpstring("Sets a boolean value specifying whether or not video is stretched")]
        HRESULT stretchToFit([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propget, helpstring("Returns a boolen value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propput, helpstring("Sets a boolean value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([in] VARIANT_BOOL bEnabled);
}



[
    object,
    uuid(F75CCEC0-C67C-475c-931E-8719870BEE7D),
    dual,
    helpstring("IWMPErrorItem2: Public interface."),
    pointer_default(unique)
]
interface IWMPErrorItem2 : IWMPErrorItem
{
    // properties
    [ id(DISPID_WMPERRORITEM2_CONDITION), propget, helpstring("Returns condition for the error") ]
        HRESULT condition( [out, retval] long * plCondition );
}

[
    object,
    uuid(CBB92747-741F-44fe-AB5B-F1A48F3B2A59),
    helpstring("IWMPRemoteMediaServices: Public interface for Windows Media Player SDK."),
    pointer_default(unique)    
]
interface IWMPRemoteMediaServices : IUnknown
{
    // methods
    HRESULT GetServiceType( [out] BSTR * pbstrType );
    HRESULT GetApplicationName( [out] BSTR * pbstrName );
    HRESULT GetScriptableObject( [out] BSTR * pbstrName, [out] IDispatch ** ppDispatch );
    HRESULT GetCustomUIMode( [out] BSTR * pbstrFile);
}

// {B2A7FD52-301F-4348-B93A-638C6DE49229}
cpp_quote("EXTERN_GUID( CLSID_WMPSkinManager, 0xB2A7FD52,0x301F,0x4348, 0xB9, 0x3A, 0x63, 0x8C, 0x6D, 0xE4, 0x92, 0x29 );")

[
    object,
    uuid(076F2FA6-ED30-448B-8CC5-3F3EF3529C7A), 
    helpstring("IWMPSkinManager: Public interface for Windows Media Player SDK."),
    pointer_default(unique)
]
interface IWMPSkinManager : IUnknown
{
    HRESULT SetVisualStyle([in] BSTR bstrPath);
};

//////////////////////////////////////////////////////////////////////
//          IWMPMetadata Interfaces
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(5C29BBE0-F87D-4c45-AA28-A70F0230FFA9),
    dual,
    helpstring("IWMPMetadataPicture: Not Public.  Internal interface used by Windows Media Player."),
    pointer_default(unique)    
]
interface IWMPMetadataPicture : IDispatch
{
    [ id(DISPID_WMPMETADATA_PICTURE_MIMETYPE), propget]
        HRESULT mimeType([out, retval] BSTR *pbstrMimeType);
    [ id(DISPID_WMPMETADATA_PICTURE_PICTURETYPE), propget]
        HRESULT pictureType([out, retval] BSTR *pbstrPictureType);
    [ id(DISPID_WMPMETADATA_PICTURE_DESCRIPTION), propget]
        HRESULT description([out, retval] BSTR *pbstrDescription);
    [ id(DISPID_WMPMETADATA_PICTURE_URL), propget]
        HRESULT URL([out, retval] BSTR *pbstrURL);
}

[
    object,
    uuid(769A72DB-13D2-45e2-9C48-53CA9D5B7450),
    dual,
    helpstring("IWMPMetadataText: Not Public.  Internal interface used by Windows Media Player."),
    pointer_default(unique)
]
interface IWMPMetadataText : IDispatch
{
    [ id(DISPID_WMPMETADATA_TEXT_DESCRIPTION), propget]
        HRESULT description([out, retval] BSTR *pbstrDescription);
    [ id(DISPID_WMPMETADATA_TEXT_TEXT), propget]
        HRESULT text([out, retval] BSTR *pbstrText);
}

//////////////////////////////////////////////////////////////////////
//          IWMPMedia3 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(F118EFC7-F03A-4fb4-99C9-1C02A5C1065B),
    dual,
    helpstring("IWMPMedia3: Public interface."),
    pointer_default(unique)
]
interface IWMPMedia3 : IWMPMedia2
{
    [
        id(DISPID_WMPMEDIA3_GETATTRIBUTECOUNTBYTYPE)]
        HRESULT getAttributeCountByType([in] BSTR bstrType, [in] BSTR bstrLanguage, [out, retval] long *plCount);
    [
        id(DISPID_WMPMEDIA3_GETITEMINFOBYTYPE)]
        HRESULT getItemInfoByType([in] BSTR bstrType, [in] BSTR bstrLanguage, [in] long lIndex, [out, retval] VARIANT *pvarValue);
}


//////////////////////////////////////////////////////////////////////
//          IWMPSettings2 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(FDA937A4-EECE-4da5-A0B6-39BF89ADE2C2),
    dual,
    helpstring("IWMPSettings2: Public interface."),
    pointer_default(unique)
]
interface IWMPSettings2 : IWMPSettings
{
    [ id(DISPID_WMPSETTINGS2_DEFAULTAUDIOLANGUAGE), propget, helpstring("Returns the LCID of default audio language")]
        HRESULT defaultAudioLanguage( [out, retval] long *plLangID );
    [ id(DISPID_WMPSETTINGS2_LIBRARYACCESSRIGHTS), propget]
        HRESULT mediaAccessRights( [out, retval] BSTR * pbstrRights );
    [ id(DISPID_WMPSETTINGS2_REQUESTLIBRARYACCESSRIGHTS)]
        HRESULT requestMediaAccessRights( [in] BSTR bstrDesiredAccess, [out, retval] VARIANT_BOOL * pvbAccepted );
}


//////////////////////////////////////////////////////////////////////
//          IWMPControls3 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(A1D1110E-D545-476a-9A78-AC3E4CB1E6BD),
    dual,
    helpstring("IWMPControls3: Public interface."),
    pointer_default(unique)
]
interface IWMPControls3 : IWMPControls2
{
    [ id(DISPID_WMPCONTROLS3_AUDIOLANGUAGECOUNT), propget, helpstring("Returns the count of supported audio languages")]
        HRESULT audioLanguageCount( [out, retval] long *plCount );
    [ id(DISPID_WMPCONTROLS3_GETAUDIOLANGUAGEID), helpstring("Returns the LCID corresponding to the index")]
        HRESULT getAudioLanguageID( [in] long lIndex, [out, retval] long *plLangID );
    [ id(DISPID_WMPCONTROLS3_GETAUDIOLANGUAGEDESC), helpstring("Returns the desription corresponding to the index")]
        HRESULT getAudioLanguageDescription( [in] long lIndex, [out, retval] BSTR *pbstrLangDesc );
    [ id(DISPID_WMPCONTROLS3_CURRENTAUDIOLANGUAGE), propget, helpstring("Gets the current audio language setting for playback")]
        HRESULT currentAudioLanguage( [out, retval] long *plLangID );
    [ id(DISPID_WMPCONTROLS3_CURRENTAUDIOLANGUAGE), propput, helpstring("Sets the current audio language setting for playback")]
        HRESULT currentAudioLanguage( [in] long lLangID );
    [ id(DISPID_WMPCONTROLS3_CURRENTAUDIOLANGUAGEINDEX), propget, helpstring("Gets the current audio language index setting for playback")]
        HRESULT currentAudioLanguageIndex( [out, retval] long *plIndex );
    [ id(DISPID_WMPCONTROLS3_CURRENTAUDIOLANGUAGEINDEX), propput, helpstring("Sets the current audio language index setting for playback")]
        HRESULT currentAudioLanguageIndex( [in] long lIndex );
    [ id(DISPID_WMPCONTROLS3_GETLANGUAGENAME), helpstring("Returns the human-readable name of language specified by LCID")]
        HRESULT getLanguageName( [in] long lLangID, [out, retval] BSTR *pbstrLangName );
    [ id(DISPID_WMPCONTROLS3_CURRENTPOSITIONTIMECODE), propget, helpstring( "Returns the current timecode position in media" ) ]
        HRESULT currentPositionTimecode( [out, retval] BSTR * bstrTimecode );
    [ id(DISPID_WMPCONTROLS3_CURRENTPOSITIONTIMECODE), propput, helpstring( "Sets the current timecode position in media" ) ]
        HRESULT currentPositionTimecode( [in] BSTR bstrTimecode );
}


//////////////////////////////////////////////////////////////////////
//          IWMPClosedCaption2 Interface
//////////////////////////////////////////////////////////////////////
[
    object,
    uuid(350BA78B-6BC8-4113-A5F5-312056934EB6),
    dual,
    helpstring("IWMPClosedCaption2: Public interface."),
    pointer_default(unique)
]
interface IWMPClosedCaption2 : IWMPClosedCaption
{
    [  id( DISPID_WMPCLOSEDCAPTION2_GETLANGCOUNT ), propget, helpstring( "Returns the count of SAMI languages" ) ]
        HRESULT SAMILangCount( [out, retval] long * plCount );
    [  id( DISPID_WMPCLOSEDCAPTION2_GETLANGNAME ), helpstring( "Returns the name of a SAMI language by index" ) ]
        HRESULT getSAMILangName( [in] long nIndex, [out, retval] BSTR * pbstrName );
    [  id( DISPID_WMPCLOSEDCAPTION2_GETLANGID ), helpstring( "Returns the ID of a SAMI language by index" ) ]
        HRESULT getSAMILangID( [in] long nIndex, [out, retval] long * plLangID );
    [  id( DISPID_WMPCLOSEDCAPTION2_GETSTYLECOUNT ), propget, helpstring( "Returns the count of SAMI styles" ) ]
        HRESULT SAMIStyleCount( [out, retval] long * plCount );
    [  id( DISPID_WMPCLOSEDCAPTION2_GETSTYLENAME ), helpstring( "Returns the name of a SAMI style by index" ) ]
        HRESULT getSAMIStyleName( [in] long nIndex, [out, retval] BSTR * pbstrName );
}


//////////////////////////////////////////////////////////////////////
//          IWMPPlayerApplication Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(40897764-CEAB-47be-AD4A-8E28537F9BBF),
    dual,
    helpstring("IWMPPlayerApplication: Public interface."),
    pointer_default(unique)
]
interface IWMPPlayerApplication : IDispatch
{
    [ id(DISPID_WMPPLAYERAPP_SWITCHTOPLAYERAPPLICATION), helpstring("Switches the display to player application")]
        HRESULT switchToPlayerApplication();
    [ id(DISPID_WMPPLAYERAPP_SWITCHTOCONTROL), helpstring("Switches the display to control")]
        HRESULT switchToControl();
    [ id(DISPID_WMPPLAYERAPP_PLAYERDOCKED), propget, helpstring("Returns a boolean value specifying whether or not the player is docked")]
        HRESULT playerDocked([out, retval] VARIANT_BOOL *pbPlayerDocked);
    [ id(DISPID_WMPPLAYERAPP_HASDISPLAY), propget, helpstring("Returns a boolean value specifying whether or not the control has display")]
        HRESULT hasDisplay([out, retval] VARIANT_BOOL *pbHasDisplay);
}

//////////////////////////////////////////////////////////////////////
//          IWMPCore3 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(7587C667-628F-499f-88E7-6A6F4E888464),
    dual,
    helpstring("IWMPCore3: Public interface."),
    pointer_default(unique)
]
interface IWMPCore3 : IWMPCore2
{
    // methods
    [ id( DISPID_WMPCORE3_NEWPLAYLIST ), helpstring( "Creates a new playlist object" ) ]
        HRESULT newPlaylist( [in] BSTR bstrName, [in] BSTR bstrURL, [out, retval] IWMPPlaylist **ppPlaylist );
    [ id( DISPID_WMPCORE3_NEWMEDIA ), helpstring( "Creates a new media object" ) ]
        HRESULT newMedia( [in] BSTR bstrURL, [out, retval] IWMPMedia **ppMedia );
}

//////////////////////////////////////////////////////////////////////
//          IWMPPlayer4 Interface
//////////////////////////////////////////////////////////////////////

[
    object,
    uuid(6C497D62-8919-413c-82DB-E935FB3EC584),
    dual,
    helpstring("IWMPPlayer4: Public interface."),
    pointer_default(unique)
]
interface IWMPPlayer4 : IWMPCore3
{
    [ id(DISPID_WMPOCX_ENABLED), propget, helpstring("Returns a boolean value specifying whether or not the control is enabled")]
        HRESULT enabled([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX_ENABLED), propput, helpstring("Sets a boolean value specifying whether or not the control is enabled")]
        HRESULT enabled([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX_FULLSCREEN), propget, helpstring("Returns a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen([out, retval] VARIANT_BOOL *pbFullScreen);
    [ id(DISPID_WMPOCX_FULLSCREEN), propput, helpstring("Sets a boolean value specifying whether or not the control is in full screen mode")]
        HRESULT fullScreen(VARIANT_BOOL bFullScreen);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propget, helpstring("Returns a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu([out, retval] VARIANT_BOOL *pbEnableContextMenu);
    [ id(DISPID_WMPOCX_ENABLECONTEXTMENU), propput, helpstring("Sets a boolean value specifying whether or not the context menu is enabled on the control")]
        HRESULT enableContextMenu(VARIANT_BOOL bEnableContextMenu);
    [ id(DISPID_WMPOCX_UIMODE), propput, helpstring("Specifies the ui mode to select")]
        HRESULT uiMode([in] BSTR bstrMode);
    [ id(DISPID_WMPOCX_UIMODE), propget, helpstring("Returns the currently selected ui mode")]
        HRESULT uiMode([out, retval] BSTR *pbstrMode);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propget, helpstring("Returns a boolean value specifying whether or not video is stretched")]
        HRESULT stretchToFit([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_STRETCHTOFIT), propput, helpstring("Sets a boolean value specifying whether or not video is stretched")]
        HRESULT stretchToFit([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propget, helpstring("Returns a boolean value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([out, retval] VARIANT_BOOL *pbEnabled);
    [ id(DISPID_WMPOCX2_WINDOWLESSVIDEO), propput, helpstring("Sets a boolean value specifying whether or not video is windowless")]
        HRESULT windowlessVideo([in] VARIANT_BOOL bEnabled);
    [ id(DISPID_WMPOCX4_ISREMOTE), propget, helpstring("Indicates whether the player is running remotely")]
        HRESULT isRemote( [out, retval] VARIANT_BOOL *pvarfIsRemote );
    [ id(DISPID_WMPOCX4_PLAYERAPPLICATION ), propget, helpstring( "Returns the player application handler" ) ]
        HRESULT playerApplication( [out, retval] IWMPPlayerApplication **ppIWMPPlayerApplication );
    [ id(DISPID_WMPOCX4_OPENPLAYER ), helpstring( "Opens the player with the specified URL" ) ]
        HRESULT openPlayer( [in] BSTR bstrURL );
}

[
    object,
    uuid(1D01FBDB-ADE2-4c8d-9842-C190B95C3306),
    helpstring("IWMPPlayerServices: Public interface for Windows Media Player SDK."),
    pointer_default(unique)
]
interface IWMPPlayerServices : IUnknown
{
    HRESULT activateUIPlugin([in] BSTR bstrPlugin);
    HRESULT setTaskPane([in] BSTR bstrTaskPane);
    HRESULT setTaskPaneURL( [in] BSTR bstrTaskPane, [in] BSTR bstrURL, [in] BSTR bstrFriendlyName);
}

cpp_quote("struct DECLSPEC_UUID(\"6BF52A50-394A-11d3-B153-00C04F79FAA6\") WMPLib;")
cpp_quote("struct DECLSPEC_UUID(\"DF333473-2CF7-4be2-907F-9AAD5661364F\") WMPRemoteMediaServices;")

[
    uuid(6BF52A50-394A-11d3-B153-00C04F79FAA6),
    version(1.0),
    helpstring("Windows Media Player")
]
library WMPLib
{
    importlib("stdole32.tlb");
    importlib("stdole2.tlb");

    //////////////////////////////////////////////////////////////////////
    //  Events
    //////////////////////////////////////////////////////////////////////

    [
        object,
        uuid(19A6627B-DA9E-47c1-BB23-00B5E668236A),
        helpstring("IWMPEvents: Public interface."),
        pointer_default(unique)
    ]
    interface IWMPEvents : IUnknown
    {
        // Graph creation
        [ id( DISPID_WMPCOREEVENT_OPENSTATECHANGE ), helpstring( "Sent when the control changes OpenState" ) ]
            void OpenStateChange( [in] long NewState );

        // control
        [ id( DISPID_WMPCOREEVENT_PLAYSTATECHANGE ), helpstring( "Sent when the control changes PlayState" ) ]
            void PlayStateChange( [in] long NewState );
        [ id( DISPID_WMPCOREEVENT_AUDIOLANGUAGECHANGE ), helpstring( "Sent when the current audio language has changed" ) ]
            void AudioLanguageChange( [in] long LangID );

        // Status
        [ id( DISPID_WMPCOREEVENT_STATUSCHANGE ), helpstring( "Sent when the status string changes" ) ]
            void StatusChange();

        // content
        [ id( DISPID_WMPCOREEVENT_SCRIPTCOMMAND ), helpstring( "Sent when a synchronized command or URL is received" ) ]
            void ScriptCommand( [in] BSTR scType, [in] BSTR Param );

        // network
        [ id( DISPID_WMPCOREEVENT_NEWSTREAM ), helpstring( "Sent when a new stream is started in a channel" ) ]
            void NewStream();
        [ id( DISPID_WMPCOREEVENT_DISCONNECT ), helpstring( "Sent when the control is disconnected from the server" ) ]
            void Disconnect( [in] long Result );
        [ id( DISPID_WMPCOREEVENT_BUFFERING ), helpstring( "Sent when the control begins or ends buffering" ) ]
            void Buffering( [in] VARIANT_BOOL Start );

        // error
        [ id( DISPID_WMPCOREEVENT_ERROR ), helpstring( "Sent when the control has an error condition" ) ]
            void Error();

        // warning
        [ id( DISPID_WMPCOREEVENT_WARNING ), helpstring( "Sent when the control encounters a problem" ) ]
            void Warning( [in] long WarningType, [in] long Param, [in] BSTR Description );

        // seek
        [ id( DISPID_WMPCOREEVENT_ENDOFSTREAM ), helpstring( "Sent when the end of file is reached" ) ]
            void EndOfStream( [in] long Result );
        [ id( DISPID_WMPCOREEVENT_POSITIONCHANGE), helpstring("Indicates that the current position of the movie has changed")]
            void PositionChange([in] double oldPosition, [in] double newPosition);
        [ id( DISPID_WMPCOREEVENT_MARKERHIT ), helpstring( "Sent when a marker is reached" ) ]
            void MarkerHit( [in] long MarkerNum );
        [ id( DISPID_WMPCOREEVENT_DURATIONUNITCHANGE), helpstring("Indicates that the unit used to express duration and position has changed")]
            void DurationUnitChange( [in] long NewDurationUnit );

        // cdrom
        [ id( DISPID_WMPCOREEVENT_CDROMMEDIACHANGE), helpstring("Indicates that the CD ROM media has changed") ]
                void CdromMediaChange( [in] long CdromNum );

        // playlist
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCHANGE), helpstring("Sent when a playlist changes") ]
            void PlaylistChange( [in] IDispatch * Playlist, [in] WMPPlaylistChangeEventType change );
        [ id( DISPID_WMPCOREEVENT_CURRENTPLAYLISTCHANGE), helpstring("Sent when the current playlist changes") ]
            void CurrentPlaylistChange( [in] WMPPlaylistChangeEventType change );
        [ id( DISPID_WMPCOREEVENT_CURRENTPLAYLISTITEMAVAILABLE), helpstring("Sent when a current playlist item becomes available") ]
            void CurrentPlaylistItemAvailable( [in] BSTR bstrItemName );
        [ id( DISPID_WMPCOREEVENT_MEDIACHANGE), helpstring("Sent when a media object changes") ]
            void MediaChange( [in] IDispatch * Item );
        [ id( DISPID_WMPCOREEVENT_CURRENTMEDIAITEMAVAILABLE), helpstring("Sent when a current media item becomes available") ]
            void CurrentMediaItemAvailable( [in] BSTR bstrItemName );
        [ id( DISPID_WMPCOREEVENT_CURRENTITEMCHANGE), helpstring("Sent when the item selection on the current playlist changes") ]
            void CurrentItemChange( [in] IDispatch *pdispMedia);
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONCHANGE), helpstring("Sent when the media collection needs to be requeried") ]
            void MediaCollectionChange();
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGADDED), helpstring("Sent when an attribute string is added in the media collection") ]
            void MediaCollectionAttributeStringAdded( [in] BSTR bstrAttribName,  [in] BSTR bstrAttribVal );
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGREMOVED), helpstring("Sent when an attribute string is removed from the media collection") ]
            void MediaCollectionAttributeStringRemoved( [in] BSTR bstrAttribName,  [in] BSTR bstrAttribVal );
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGCHANGED), helpstring("Sent when an attribute string is changed in the media collection") ]
            void MediaCollectionAttributeStringChanged([in] BSTR bstrAttribName, [in] BSTR bstrOldAttribVal, [in] BSTR bstrNewAttribVal);
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONCHANGE), helpstring("Sent when playlist collection needs to be requeried") ]
            void PlaylistCollectionChange();
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTADDED), helpstring("Sent when a playlist is added to the playlist collection") ]
            void PlaylistCollectionPlaylistAdded([in] BSTR bstrPlaylistName);
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTREMOVED), helpstring("Sent when a playlist is removed from the playlist collection") ]
            void PlaylistCollectionPlaylistRemoved([in] BSTR bstrPlaylistName);
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTSETASDELETED), helpstring("Sent when a playlist has been set or reset as deleted")]
            void PlaylistCollectionPlaylistSetAsDeleted([in] BSTR bstrPlaylistName, [in] VARIANT_BOOL varfIsDeleted);
        [ id( DISPID_WMPCOREEVENT_MODECHANGE), helpstring("Playlist playback mode has changed")]
            void ModeChange([in] BSTR ModeName, [in] VARIANT_BOOL NewValue);
        [ id( DISPID_WMPCOREEVENT_MEDIAERROR ), helpstring( "Sent when the media object has an error condition" ) ]
            void MediaError( [in] IDispatch * pMediaObject);
        [ id( DISPID_WMPCOREEVENT_OPENPLAYLISTSWITCH), helpstring("Current playlist switch with no open state change") ]
            void OpenPlaylistSwitch( [in] IDispatch *pItem );

        // dvd
        [ id( DISPID_WMPCOREEVENT_DOMAINCHANGE ), helpstring( "Send a current domain" ) ]
            void DomainChange([in] BSTR strDomain);

        // OCX
        [ id( DISPID_WMPOCXEVENT_SWITCHEDTOPLAYERAPPLICATION ), helpstring( "Sent when display switches to player application" ) ]
            void SwitchedToPlayerApplication();
        [ id( DISPID_WMPOCXEVENT_SWITCHEDTOCONTROL ), helpstring( "Sent when display switches to control" ) ]
            void SwitchedToControl();
        [ id( DISPID_WMPOCXEVENT_PLAYERDOCKEDSTATECHANGE ), helpstring( "Sent when the player docks or undocks" ) ]
            void PlayerDockedStateChange();
        [ id( DISPID_WMPOCXEVENT_PLAYERRECONNECT ), helpstring( "Sent when the OCX reconnects to the player" ) ]
            void PlayerReconnect();
        [ id( DISPID_WMPOCXEVENT_CLICK ), helpstring( "Occurs when a user clicks the mouse" ) ]
            void Click( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_DOUBLECLICK ), helpstring( "Occurs when a user double-clicks the mouse" ) ]
            void DoubleClick( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_KEYDOWN ), helpstring( "Occurs when a key is pressed" ) ]
            void KeyDown( [in] short nKeyCode, [in] short nShiftState );
        [ id( DISPID_WMPOCXEVENT_KEYPRESS ), helpstring( "Occurs when a key is pressed and released" ) ]
            void KeyPress( [in] short nKeyAscii );
        [ id( DISPID_WMPOCXEVENT_KEYUP ), helpstring( "Occurs when a key is released" ) ]
            void KeyUp( [in] short nKeyCode, [in] short nShiftState );
        [ id( DISPID_WMPOCXEVENT_MOUSEDOWN ), helpstring( "Occurs when a mouse button is pressed" ) ]
            void MouseDown( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_MOUSEMOVE ), helpstring( "Occurs when a mouse pointer is moved" ) ]
            void MouseMove( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_MOUSEUP ), helpstring( "Occurs when a mouse button is released" ) ]
            void MouseUp( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
    };


    [
        uuid(6BF52A51-394A-11d3-B153-00C04F79FAA6),
        helpstring("_WMPOCXEvents: Public interface."),
        hidden
    ]
    dispinterface _WMPOCXEvents
    {
        properties:
        methods:
        // Graph creation
        [ id( DISPID_WMPCOREEVENT_OPENSTATECHANGE ), helpstring( "Sent when the control changes OpenState" ) ]
            void OpenStateChange( [in] long NewState );

        // control
        [ id( DISPID_WMPCOREEVENT_PLAYSTATECHANGE ), helpstring( "Sent when the control changes PlayState" ) ]
            void PlayStateChange( [in] long NewState );
        [ id( DISPID_WMPCOREEVENT_AUDIOLANGUAGECHANGE ), helpstring( "Sent when the current audio language has changed" ) ]
            void AudioLanguageChange( [in] long LangID );

        // Status
        [ id( DISPID_WMPCOREEVENT_STATUSCHANGE ), helpstring( "Sent when the status string changes" ) ]
            void StatusChange();

        // content
        [ id( DISPID_WMPCOREEVENT_SCRIPTCOMMAND ), helpstring( "Sent when a synchronized command or URL is received" ) ]
            void ScriptCommand( [in] BSTR scType, [in] BSTR Param );

        // network
        [ id( DISPID_WMPCOREEVENT_NEWSTREAM ), helpstring( "Sent when a new stream is started in a channel" ) ]
            void NewStream();
        [ id( DISPID_WMPCOREEVENT_DISCONNECT ), helpstring( "Sent when the control is disconnected from the server" ) ]
            void Disconnect( [in] long Result );
        [ id( DISPID_WMPCOREEVENT_BUFFERING ), helpstring( "Sent when the control begins or ends buffering" ) ]
            void Buffering( [in] VARIANT_BOOL Start );

        // error
        [ id( DISPID_WMPCOREEVENT_ERROR ), helpstring( "Sent when the control has an error condition" ) ]
            void Error();

        // warning
        [ id( DISPID_WMPCOREEVENT_WARNING ), helpstring( "Sent when the control encounters a problem" ) ]
            void Warning( [in] long WarningType, [in] long Param, [in] BSTR Description );

        // seek
        [ id( DISPID_WMPCOREEVENT_ENDOFSTREAM ), helpstring( "Sent when the end of file is reached" ) ]
            void EndOfStream( [in] long Result );
        [ id( DISPID_WMPCOREEVENT_POSITIONCHANGE), helpstring("Indicates that the current position of the movie has changed")]
            void PositionChange([in] double oldPosition, [in] double newPosition);
        [ id( DISPID_WMPCOREEVENT_MARKERHIT ), helpstring( "Sent when a marker is reached" ) ]
            void MarkerHit( [in] long MarkerNum );
        [ id( DISPID_WMPCOREEVENT_DURATIONUNITCHANGE), helpstring("Indicates that the unit used to express duration and position has changed")]
            void DurationUnitChange( [in] long NewDurationUnit );

        // cdrom
        [ id( DISPID_WMPCOREEVENT_CDROMMEDIACHANGE), helpstring("Indicates that the CD ROM media has changed") ]
                void CdromMediaChange( [in] long CdromNum );

        // playlist
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCHANGE), helpstring("Sent when a playlist changes") ]
            void PlaylistChange( [in] IDispatch * Playlist, [in] WMPPlaylistChangeEventType change );
        [ id( DISPID_WMPCOREEVENT_CURRENTPLAYLISTCHANGE), helpstring("Sent when the current playlist changes") ]
            void CurrentPlaylistChange( [in] WMPPlaylistChangeEventType change );
        [ id( DISPID_WMPCOREEVENT_CURRENTPLAYLISTITEMAVAILABLE), helpstring("Sent when a current playlist item becomes available") ]
            void CurrentPlaylistItemAvailable( [in] BSTR bstrItemName );
        [ id( DISPID_WMPCOREEVENT_MEDIACHANGE), helpstring("Sent when a media object changes") ]
            void MediaChange( [in] IDispatch * Item );
        [ id( DISPID_WMPCOREEVENT_CURRENTMEDIAITEMAVAILABLE), helpstring("Sent when a current media item becomes available") ]
            void CurrentMediaItemAvailable( [in] BSTR bstrItemName );
        [ id( DISPID_WMPCOREEVENT_CURRENTITEMCHANGE), helpstring("Sent when the item selection on the current playlist changes") ]
            void CurrentItemChange( [in] IDispatch *pdispMedia);
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONCHANGE), helpstring("Sent when the media collection needs to be requeried") ]
            void MediaCollectionChange();
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGADDED), helpstring("Sent when an attribute string is added in the media collection") ]
            void MediaCollectionAttributeStringAdded( [in] BSTR bstrAttribName,  [in] BSTR bstrAttribVal );
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGREMOVED), helpstring("Sent when an attribute string is removed from the media collection") ]
            void MediaCollectionAttributeStringRemoved( [in] BSTR bstrAttribName,  [in] BSTR bstrAttribVal );
        [ id( DISPID_WMPCOREEVENT_MEDIACOLLECTIONATTRIBUTESTRINGCHANGED), helpstring("Sent when an attribute string is changed in the media collection") ]
            void MediaCollectionAttributeStringChanged([in] BSTR bstrAttribName, [in] BSTR bstrOldAttribVal, [in] BSTR bstrNewAttribVal);
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONCHANGE), helpstring("Sent when playlist collection needs to be requeried") ]
            void PlaylistCollectionChange();
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTADDED), helpstring("Sent when a playlist is added to the playlist collection") ]
            void PlaylistCollectionPlaylistAdded([in] BSTR bstrPlaylistName);
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTREMOVED), helpstring("Sent when a playlist is removed from the playlist collection") ]
            void PlaylistCollectionPlaylistRemoved([in] BSTR bstrPlaylistName);
        [ id( DISPID_WMPCOREEVENT_PLAYLISTCOLLECTIONPLAYLISTSETASDELETED), helpstring("Sent when a playlist has been set or reset as deleted")]
            void PlaylistCollectionPlaylistSetAsDeleted([in] BSTR bstrPlaylistName, [in] VARIANT_BOOL varfIsDeleted);
        [ id( DISPID_WMPCOREEVENT_MODECHANGE), helpstring("Playlist playback mode has changed")]
            void ModeChange([in] BSTR ModeName, [in] VARIANT_BOOL NewValue);
        [ id( DISPID_WMPCOREEVENT_MEDIAERROR ), helpstring( "Sent when the media object has an error condition" ) ]
            void MediaError( [in] IDispatch * pMediaObject);
        [ id( DISPID_WMPCOREEVENT_OPENPLAYLISTSWITCH), helpstring("Current playlist switch with no open state change") ]
            void OpenPlaylistSwitch( [in] IDispatch *pItem );

        // dvd
        [ id( DISPID_WMPCOREEVENT_DOMAINCHANGE ), helpstring( "Send a current domain" ) ]
            void DomainChange([in] BSTR strDomain);

        // OCX
        [ id( DISPID_WMPOCXEVENT_SWITCHEDTOPLAYERAPPLICATION ), helpstring( "Sent when display switches to player application" ) ]
            void SwitchedToPlayerApplication();
        [ id( DISPID_WMPOCXEVENT_SWITCHEDTOCONTROL ), helpstring( "Sent when display switches to control" ) ]
            void SwitchedToControl();
        [ id( DISPID_WMPOCXEVENT_PLAYERDOCKEDSTATECHANGE ), helpstring( "Sent when the player docks or undocks" ) ]
            void PlayerDockedStateChange();
        [ id( DISPID_WMPOCXEVENT_PLAYERRECONNECT ), helpstring( "Sent when the OCX reconnects to the player" ) ]
            void PlayerReconnect();
        [ id( DISPID_WMPOCXEVENT_CLICK ), helpstring( "Occurs when a user clicks the mouse" ) ]
            void Click( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_DOUBLECLICK ), helpstring( "Occurs when a user double-clicks the mouse" ) ]
            void DoubleClick( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_KEYDOWN ), helpstring( "Occurs when a key is pressed" ) ]
            void KeyDown( [in] short nKeyCode, [in] short nShiftState );
        [ id( DISPID_WMPOCXEVENT_KEYPRESS ), helpstring( "Occurs when a key is pressed and released" ) ]
            void KeyPress( [in] short nKeyAscii );
        [ id( DISPID_WMPOCXEVENT_KEYUP ), helpstring( "Occurs when a key is released" ) ]
            void KeyUp( [in] short nKeyCode, [in] short nShiftState );
        [ id( DISPID_WMPOCXEVENT_MOUSEDOWN ), helpstring( "Occurs when a mouse button is pressed" ) ]
            void MouseDown( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_MOUSEMOVE ), helpstring( "Occurs when a mouse pointer is moved" ) ]
            void MouseMove( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
        [ id( DISPID_WMPOCXEVENT_MOUSEUP ), helpstring( "Occurs when a mouse button is released" ) ]
            void MouseUp( [in] short nButton, [in] short nShiftState, [in] long fX, [in] long fY );
    }


    //////////////////////////////////////////////////////////////////////
    //      OCX Class
    //////////////////////////////////////////////////////////////////////
    [
        uuid(6BF52A52-394A-11d3-B153-00C04F79FAA6),
        helpstring("Windows Media Player ActiveX Control")
    ]
    coclass WindowsMediaPlayer
    {
        [default] interface IWMPPlayer4;
        interface IWMPPlayer3;
        interface IWMPPlayer2;
        interface IWMPPlayer;
        interface IWMPControls;
        interface IWMPSettings;
        interface IWMPPlaylist;
        interface IWMPMedia;
        interface IWMPMediaCollection;
        interface IWMPPlaylistCollection;
        interface IWMPCdromCollection;
        interface IWMPError;
        interface IWMPErrorItem;
        interface IWMPErrorItem2;
        interface IWMPClosedCaption;
        interface IWMPDVD;
        interface IWMPControls2;
        interface IWMPMedia2;
        interface IWMPMedia3;
        interface IWMPMetadataPicture;
        interface IWMPMetadataText;
        interface IWMPSettings2;
        interface IWMPControls3;
        interface IWMPClosedCaption2;
        [default, source] dispinterface _WMPOCXEvents;

    };

};

//*****************************************************************************
//
//  End of File
//
//*****************************************************************************

